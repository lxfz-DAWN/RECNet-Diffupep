# 孪生神经网络

## 抽象
输入两个序列，经过ESMC进行Embeding后输入到神经网络中，评估序列相似度。

## 介绍
$\hspace{1.8em}$项目使用 Siamese Network 和 Transformer 架构对蛋白质序列进行特征提取，并通过对比损失函数来进行训练和验证。Siamese Network 适用于比较两个输入序列的相似性，广泛应用于人脸识别、手写签名验证等领域。在这个项目中，我们将其应用于蛋白质序列的相似性比较。

## 项目结构
- [Test4SNW](Test4SNW.ipynb)为测试文件
- [SNW_config](SNW_config.json): 配置文件，包含训练参数和路径信息。
- 网络模型架构参考了[SiameseNetwork孪生神经网络原理及实现](https://zhuanlan.zhihu.com/p/677110509)；[ChangeFormer](https://github.com/wgcban/ChangeFormer)
- RUN `/home/users/hcdai/miniconda3/envs/ESMC/bin/python /home/users/hcdai/AI-peptide/Seq2Score/SiameseNetWork/Test4SNW.py`

## 工作进度

- [x] 完成模型架构设计
  - [x] 定义模型架构——前向传播部分
  - [x] 定义损失函数
  - [x] 选择优化器
  - [x] 定义训练循环
  - [x] 可视化代码结构
- [ ] 数据准备模块
  - [ ] 数据清洗及标签化
  - [x] 数据处理与加载模块
    - [x] 自定义 Dataset
    - [x] 使用 DataLoader 加载数据
- [ ] 训练模型模块
  - [ ] 测试模型
  - [x] 保存模型模块
  - [x] 加载模型继续训练
  - [ ] 部署模型
- [ ] 模型训练
  - [ ] est-all数据集训练
  - [ ] RS_PDB1数据集训练
- [ ] 20250121会议后下一步工作
  - [ ] 精简前向层
  - [ ] cross attention

## 问题&记录
- 有两个想法
  - 其一是将L和R分别输入到两个不同的网络（合并起来即伪孪生神经网络），抽象序列的特征出来后，使用ContrastiveLoss评价相似性并进行反向传播以训练网络。参照文本识别工作中的验证标题与正文的描述是否一致（标题和正文长度差别很大），或者文字是否描述了一幅图片（一个是图片，一个是文字）的思想，使用伪孪生神经网络，评估L和R的一致性（该一致性代表了两个序列在对接上的某个维度的相似性，该相似性由网络学习并通过loss评价），此时标签可以为rosettaScore的数据（将数据映射到0-1标签）。这样做的好处在于，单独L进过网络后所输出的信息，可能即是蛋白质对接的相关信息。
  - 其二是分别输入两组L-R序列，使用同一个网络评判（此时为孪生神经网络）。这种网络能够评价两组序列在对接情况的相似性。也就是说，网络所输出的信息可能代表了L-R对接在某个维度上的表征。
- 难点
  - 训练数据：无论使用何种输入方案，都需要对序列打标签（0-1label）
  - 输出数据：如何运用孪生神经网络——学习人脸识别丨手写体识别或者文本识别的运用
  - 网络架构：现在使用CNN+transformer的结构，理由是希望CNN能够捕捉到序列的局部信息，而transformer能够捕捉到全局信息。但是，孪生神经网络的结构是否合适？未知。
  - 运行中的bug：序列长度和batch的问题, 可视化部分
    - 序列长度的问题使用NormalizedSequenceLength参数进行标准化解决（截断或者补全）
    - batch问题：区分了本模型的batch_size和ESM输出的batch_size。**但是在transformer部分又混在一起，待解决。**——**现在应该考虑重新设计网络架构和前向传播部分**
    - **可视化部分：待解决。**
  - ！可能把所有序列先送入ESMC进行embeding，保存为文件，然后网络读取文件进行训练，这样可能能够加快速度。
- AI-Bind：**不合适**
  - 其中的格式标准化也是使用填充的方法，其中孪生神经网络填充了“-1”
  - 孪生神经网络的做法：定义一个三元组（target, non binding drug, binding drug），评判与正样本的距离和负样本的距离作为损失函数
- 现在使用accelerator把所有的运算放在同一个设备上
- 增加cross attention，尝试单独使用该机制进行模型训练——变成一个二分类任务（使用BCELoss）